"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.description = exports.name = undefined;
exports.run = run;

var _libDefs = require("../lib/libDefs.js");

function validationError(errKey, errMsg, validationErrs) {
  var errors = validationErrs.get(errKey) || [];
  errors.push(errMsg);
  validationErrs.set(errKey, errors);
}

var name = exports.name = "validate-defs";
var description = exports.description = "Validates the structure of the definitions in the local repo.";
function run() {
  var validationErrors, localDefs;
  return regeneratorRuntime.async(function run$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          validationErrors = new Map();
          _context.next = 3;
          return regeneratorRuntime.awrap((0, _libDefs.getLocalLibDefs)(validationErrors));

        case 3:
          localDefs = _context.sent;

          localDefs.forEach(function (def) {
            if (def.testFilePaths.length === 0) {
              validationError(def.pkgName + "_" + def.pkgVersionStr, 'Every definition file must have at least one test file!', validationErrors);
            }
          });

          console.log(" ");

          validationErrors.forEach(function (errors, pkgNameVersion) {
            console.log("Found some problems with %s:", pkgNameVersion);
            errors.forEach(function (err) {
              return console.log("  â€¢ " + err);
            });
            console.log("");
          });

          if (!(validationErrors.size === 0)) {
            _context.next = 10;
            break;
          }

          console.log("All library definitions are named and structured correctedly. " + ("(Found " + localDefs.length + ")"));
          return _context.abrupt("return", 0);

        case 10:
          return _context.abrupt("return", 1);

        case 11:
        case "end":
          return _context.stop();
      }
    }
  }, null, this);
};